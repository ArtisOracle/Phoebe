//
//  ParticleGenerator.swift
//  Phoebe
//
//  Created by Stefan Arambasich on 12/26/2015.
//
//  Copyright (c) 2015-2018 Stefan Arambasich. All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.


import Foundation
import UIKit

/// The type for a particle - a typialias for `UIBezierPath`
typealias Particle = UIBezierPath

<<<<<<< Updated upstream:Phoebe/ParticleGenerator.swift
/**
    Coordinates with `ParticleFactory` to generate particles on a 
    reoccuring basis.
*/
open class ParticleGenerator {

    /// How many particles to generate at one unit (parcel) of time;
    /// that is to say when the next frame is rendered, it shall contain 
    /// `parcelSize` particles
    open var parcelSize = 10
    /// Desired colors of the particles
    open var colors = [UIColor]()
    /// Minimum acceptable radius size
    open var minimumRadius = 1.0
    /// Minimum acceptable radius size
    open var maxRadius = 8.0
    /// The view these particles are generated in
    open weak var view: UIView?
    
=======

// MARK: -
// MARK: ParticleGenerator

/// Coordinates with `ParticleFactory` to generate particles on a reoccuring basis.
open class ParticleGenerator {

    /// How many particles to generate at one unit  of time; that is, when the next frame is
    /// rendered, it shall contain `parcelSize` particles.
//    open var parcelSize = 10

    /// Desired colors of the particles
    open var colors = [UIColor]()

    /// Minimum acceptable radius size
    open var minimumRadius = 1.0

    /// Maximum acceptable radius size
    open var maxRadius = 8.0

    /// A weak reference to the view these particles are generated in
    open weak var view: UIView?


>>>>>>> Stashed changes:SAParticleAnimator/ParticleGenerator.swift
    /// Tells whether the generator is running or not
    public var started: Bool {
        return displayLink != nil
    }

<<<<<<< Updated upstream:Phoebe/ParticleGenerator.swift
    public init() { }

    fileprivate var lastTimestamp: CFTimeInterval = 0.0
    
    
    /// Strong ref to displaylink to coordinate drawing with screen
    fileprivate var displayLink: CADisplayLink?
    
    /**
        Start the generating of particles.
    */
    open func start() {
        displayLink = CADisplayLink(target: self, selector: #selector(ParticleGenerator.update(_:)))
        displayLink?.add(to: RunLoop.current, forMode: .commonModes)
=======
    /// Strong ref to the current display link object to coordinate drawing with screen.
    private var displayLink: CADisplayLink?

    // MARK: -
    // MARK: Methods
    
    /// Starts the generating of particles.
    open func start(with displayLink: CADisplayLink? = nil) {
        self.displayLink = displayLink ?? CADisplayLink(target: self, selector: #selector(update(_:)))
        self.displayLink?.add(to: .current, forMode: .commonModes)
>>>>>>> Stashed changes:SAParticleAnimator/ParticleGenerator.swift
    }
    
    /**`
        Stops the generator from generating more particles.
    */
    open func stop() {
<<<<<<< Updated upstream:Phoebe/ParticleGenerator.swift
        displayLink?.remove(from: RunLoop.current, forMode: .commonModes)
        displayLink?.invalidate()
        displayLink = nil
    }
}

extension ParticleGenerator {

    /**
        Generates a parcel of particles accordinng to the options.
     
        - returns: A collection of particles.
    */
    fileprivate func makeParcel() -> [Particle] {
        var result = [Particle]()
        for _ in 0 ..< parcelSize {
=======
        displayLink?.remove(from: .current, forMode: .commonModes)
        displayLink = nil
    }

}

private extension ParticleGenerator {

    /// Generates a parcel of particles according to the options.
    ///
    /// - Returns: A collection of particles.
    func makeParcel() -> [Particle] {
        return (0 ..< 1).map { _ in
>>>>>>> Stashed changes:SAParticleAnimator/ParticleGenerator.swift
            let x = CGFloat(arc4random_uniform(UInt32(view?.frame.size.width ?? 0.0))),
                y: CGFloat = 0.0,
                size = CGFloat(arc4random_uniform(UInt32(maxRadius))) + CGFloat(minimumRadius)

            let rect = CGRect(x: x, y: y, width: size, height: size)
            return ParticleFactory.particle(with: rect)
        }
    }
<<<<<<< Updated upstream:Phoebe/ParticleGenerator.swift
    
    @objc func update(_ displayLink: CADisplayLink) {
        if displayLink.timestamp - lastTimestamp >= 1.0 {
            lastTimestamp = displayLink.timestamp
            
            let particleLayers: [CAShapeLayer] = makeParcel().map {
                let l = CAShapeLayer()
                l.contentsGravity = "center"
                l.frame = CGRect(x: 0.0, y: 0.0, width: maxRadius, height: maxRadius)
                l.path = $0.cgPath
                l.fillColor = colors.random?.cgColor ?? UIColor.red.cgColor
                return l
            }
            _ = particleLayers.map {
                ParticleAnimator.animationForLayer($0)
                FrameAnimator.animationForLayer($0, inRect: view!.frame)
                view?.layer.insertSublayer($0, at: 0)
            }
=======

    @objc func update(_ displayLink: CADisplayLink) {
        guard let view = view else { return }

        let particleLayers: [CAShapeLayer] = makeParcel().map {
            let layer = CAShapeLayer()
            layer.contentsGravity = "center"
            layer.frame = CGRect(x: 0.0, y: Double(-$0.bounds.size.height), width: maxRadius, height: maxRadius)
            layer.path = $0.cgPath
            layer.fillColor = colors.random?.cgColor ?? UIColor.red.cgColor
            return layer
        }
        particleLayers.forEach {
            ParticleAnimator.animationForLayer(layer: $0)
            FrameAnimator.animationForLayer(layer: $0, in: view.frame)
            view.layer.insertSublayer($0, at: 0)
>>>>>>> Stashed changes:SAParticleAnimator/ParticleGenerator.swift
        }
    }

}


// MARK: -
// MARK: ParticleFactory

/// Creates new particles with configurable options
struct ParticleFactory {

<<<<<<< Updated upstream:Phoebe/ParticleGenerator.swift
    /**
        Creates a particle (`UIBezierPath`) with the given rect and color.
     
        - parameter rect: The desired rectangle of the particle.
        - parameter color: The particle's color
     
        - returns: A particle according to the parameters.
    */
    static func particleWithRect(_ rect: CGRect) -> Particle {
=======
    /// Creates a particle (`UIBezierPath`) with the given rect and color.
    ///
    /// - Parameter rect: The desired rectangle of the particle.
    /// - Returns: The particle's color.
    static func particle(with rect: CGRect) -> Particle {
>>>>>>> Stashed changes:SAParticleAnimator/ParticleGenerator.swift
        return UIBezierPath(ovalIn: rect)
    }

}


// MARK: -
// MARK: ParticleAnimationFactory

/// Puts together animations for a particle.
struct ParticleAnimationFactory {

<<<<<<< Updated upstream:Phoebe/ParticleGenerator.swift
    static func particleAnimation(_ rect: CGRect) -> CAAnimation {
=======
    /// Returns an animation suitable for a particle.
    ///
    /// - Returns: A `CAAnimation` object represeting a particle's animation.
    static func particleAnimation() -> CAAnimation {
>>>>>>> Stashed changes:SAParticleAnimator/ParticleGenerator.swift
        let animation: CAAnimation
        switch arc4random_uniform(3) {
        default:
            animation = opacityAnimation()
        }
        return animation
    }
    
<<<<<<< Updated upstream:Phoebe/ParticleGenerator.swift
    fileprivate static func opacityAnimation(_ minOpacity: CGFloat = 0.15, maxOpacity: CGFloat = 0.75) -> CAAnimation {
        let a = CABasicAnimation(keyPath: "opacity")
        a.beginTime = CACurrentMediaTime() + 1.0 / CFTimeInterval(arc4random_uniform(5))
        a.fromValue = minOpacity
        a.toValue = maxOpacity
        a.duration = max(0.3, CFTimeInterval(arc4random_uniform(50) / 10))
        a.autoreverses = true
        a.repeatCount = Float(CGFloat.greatestFiniteMagnitude)
        return a
=======
    /// Creates a repeating opacity fade in and out animation oscillating between a minimum and
    /// a maximum opacity value. This is responsible for the "twinkle"
    /// effect seen on the particles.
    ///
    /// - Parameters:
    ///   - minOpacity: The lowest desirable opacity. Defaults to 0.15.
    ///   - maxOpacity: The highest desirable opacity. Defaults to 0.75.
    /// - Returns: A `CAAnimation` object representing the "twinkle" animation.
    static func opacityAnimation(minOpacity: CGFloat = 0.15, maxOpacity: CGFloat = 0.75) -> CAAnimation {
        let animation = CABasicAnimation(keyPath: "opacity")
        animation.beginTime = CACurrentMediaTime() + 1.0 / (CFTimeInterval(arc4random_uniform(5)) * 0.5)
        animation.fromValue = 0.15
        animation.toValue = 0.75
        animation.duration = max(0.3, CFTimeInterval(arc4random_uniform(50) / 10)) // TODO: Add customization
        animation.autoreverses = true
        animation.repeatCount = Float(CGFloat.greatestFiniteMagnitude)
        return animation
>>>>>>> Stashed changes:SAParticleAnimator/ParticleGenerator.swift
    }

}


// MARK: -
// MARK: ParticleAnimator

/// Creates animations for the particles themselves.
struct ParticleAnimator {

<<<<<<< Updated upstream:Phoebe/ParticleGenerator.swift
    static func animationForLayer(_ layer: CALayer) {
        let a = ParticleAnimationFactory.particleAnimation(layer.frame)
//        layer.opacity = 0.0
        layer.add(a, forKey: "particle.animations")
=======
    static func animationForLayer(layer: CALayer) {
//        layer.add(ParticleAnimationFactory.particleAnimation(), forKey: "particle.animations")
>>>>>>> Stashed changes:SAParticleAnimator/ParticleGenerator.swift
    }

}


// MARK: -
// MARK: FrameAnimator

/// Creates animations for particles in frame.
struct FrameAnimator {

<<<<<<< Updated upstream:Phoebe/ParticleGenerator.swift
    static func animationForLayer(_ layer: CALayer, inRect rect: CGRect) {
        @objc class Responder: NSObject, CAAnimationDelegate {
            fileprivate weak var layer: CALayer?
            
            fileprivate func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {
                layer?.removeFromSuperlayer()
            }
        }
        let a = CABasicAnimation(keyPath: "transform.translation.y")
        a.fromValue = rect.size.height + 44.0
        a.toValue = 0.0
        a.duration = CFTimeInterval(arc4random_uniform(200) + 60) / 10.0
        a.isRemovedOnCompletion = true
        let r = Responder()
        r.layer = layer
        a.delegate = r
        a.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear)
        
        layer.add(a, forKey: "particle.translation")
=======
    /// Creates a translation animation that moves the particles upwards along the y-axis of the
    /// parent view. Applies this animation to the layer.
    ///
    /// - Parameters:
    ///   - layer: The layer to create an animation on.
    ///   - rect: The frame in which the animation should be valid.
    static func animationForLayer(layer: CALayer, in rect: CGRect) {
        @objc class AnimationDelegate: NSObject, CAAnimationDelegate {

            private weak var layer: CALayer?

            init(layer: CALayer) {
                self.layer = layer

                super.init()
            }
            
            func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {
                layer?.removeFromSuperlayer()
            }
        }

        let animation = CABasicAnimation(keyPath: #keyPath(CALayer.transform))
        animation.valueFunction = CAValueFunction(name: kCAValueFunctionTranslateY)
        animation.fromValue = rect.size.height + layer.frame.size.height
        animation.toValue = -layer.frame.size.height
        animation.duration = CFTimeInterval(arc4random_uniform(100) + 60) / 10.0 // TODO: Allow customization

        let animationDelegate = AnimationDelegate(layer: layer)
        animation.delegate = animationDelegate
        animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear)
        
        layer.add(animation, forKey: "particle.translation")
>>>>>>> Stashed changes:SAParticleAnimator/ParticleGenerator.swift
    }

}


// MARK: -
// MARK: Extensions

private extension Array {

    /// Find random element in array or nil
    var random: Array.Element? {
        return count > 0 ? self[Int(arc4random_uniform(UInt32(count)))] : nil
    }

}
